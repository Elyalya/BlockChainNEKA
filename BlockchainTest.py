#РАСШИРЕНИЕ ЦЕПОЧЕК
'''Что мне понадобится?
 1) создать класс блоков
2) проверить подлинность транзакций (узнать из чего состоит, вытащить хэши)
3) проверить валидность (текущего и следующего блока(?))
4) есть ли право создания блоков (другими словами, майнинг, придумать какое-то условие (у биткоина это угадывание случайного числа)
НАТАШЕ надо передавать блоки, которые она будет хранить
'''

import time

class Block:
    '''в этом классе необходимо сделать следующие методы:
    1) создание уникального хэша блока (с помощью библиотеки Альбины?)
    2)
    '''
    #каждый блок должен быть привязанк предыдущему по уникальному хэшу
    def __init__(self, index, timestamp, data, prev_hash):
        #index - номер блока, timestamp - когда блок был создан
        #data -данные(инфа о тразакциях) prevhash - предыдущий хэш
        self.index = index
        self.timestamp = timestamp
        self.data = data
        self.previous_hash = prev_hash
        self.hash = self.hash_block()

    def hash_block(self):
        '''кодируем информацию блока и возвращаем хэш с пом. библиотеки Альбины'''
        # создаем хэш информации о новом блоке, включая хэш предыдущего блока и информацию в самом блоке
        hash = 1
        return hash

def create_first_block():
    return 0 #Block(0, time.time(), {"proofik": 1,"transactions": None}, "0") #какой хэш у первого?

#firstBlock=create_first_block()
BLOCKCHAIN = [] #будущая цепочка, т.е blockchain
#BLOCKCHAIN.append(create_first_block()) #создали первый блок

#новый блок, то есть расширение цепочки, происходит тогда, когда выполняется какое-то условие
#в биткоин это угадывание какого-то числа
#таким образом, необходимо создать функцию, которая будет проверять произошло ли какое-то условие - т.е. доказательство

#ИДЕЯ - брать предыдущий факт доказательства - число и находить следующее делящееся на него число
def proofik(last_proof, block): #ВОПРРОс - для доказательства передавать блок или цепочку? (скорее, цепочку)

  inc = last_proof + 1 #переменная, которая будет использоваться для проверки работы

  start_time = time.time()  #время начала
  # Продолжаем увеличивать inc до тех пор, пока он не будет равен числу, которое
  # делится на число, доказывающее работу предыдущего блока
  while not (inc % last_proof == 0):
    inc += 1
    start_time = time.time()
    # (мб сравнивать текущее время с временем старта)
    # тут условие, что если нашли, прекращаем проверку, пришли к консенсусу,
    # иначе возвращаем false?? т.к кто-то другой нашел первым

  return (inc, block) # если число найдено, можно вернуть его как доказательство

#дальше уже должна быть функция майнинга
'''def mine(blockchain): #наверное, можно передавать один блок?
    BLOCKCHAIN = blockchain
    
    last_block = BLOCKCHAIN[len(BLOCKCHAIN) - 1]
    last_proof = last_block.data['proofik'] #последнее доказательство работы

    proof_now = proofik(last_proof, BLOCKCHAIN) #ищем доказательство в текущем блоке

    #проверить если не найдено доказательство, тогда заново маним

    #если же доказали, то собираем данные для нового блока
    new_block_data = {"proofik": proof_now[0], "transactions": None } #тут список транзакций должен быть

    new_block_index = last_block.index + 1
    new_block_timestamp = time.time()
    last_block_hash = last_block.hash

    #создаем новый блок
    mined_block = Block(new_block_index, new_block_timestamp, new_block_data, last_block_hash)
    BLOCKCHAIN.append(mined_block) #расширили цепочку'''